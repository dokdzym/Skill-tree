# 进程和线程
  - 进程是资源分配的基本单位，线程是调度的基本单位
  - 上下文切换
    - 发生场景
      - 多任务
      - 中断处理
      - 用户态、内核态的切换（PS：并不属于上下文交换，但不同操作系统有不同实现，因此可能存在上下文切换）
    - 步骤
      - 将特权级别提高至内核模式，进入内核
      - 保存PC（Program Counter，指令指针/程序计数器/指令计数器）、当前进程的内核栈指针（每个线程有自己的栈）、寄存器数据
      - 从陷阱返回，切换栈
      - PS:恢复与保存都发生在内核栈


# 内存碎片
  - 分类：分为内部碎片和外部碎片
    - 内部碎片属于某个进程，由于分给进程的页面内存大小可能略大于进程所需的内存大小，因此存在部分内存无法得到利用
    - 外部碎片是未被分配的内存，由于夹杂在已分配进程的内存之间，大小不足而无法被分配
  - 解决：从OS角度或从编程角度
    - 从OS角度
      - 段页式存储，避免外部碎片，但仍有内部碎片
      - 紧凑(compaction)，通过移动分配给进程的内存分区，以合并外部碎片。紧凑的条件是：所有的应用程序可动态重定位
    - 从编程角度
      - 基于结构体的内存对齐原则，注意变量的存放顺序，尽量减少padding大小
# 进程调度
  - 指标
    - 周转时间：完成时间-到达时间
    - 响应时间：响应时间-到达时间
  - 1）FIFO，先进先出，不可抢占
  - 2）SJF（Shortest Job First，最短任务优先），不可抢占当前已运行任务，但会对已到达任务按照花费时间时间排序
  - 3）STCF（Shortest Time-to-Completion First，最短完成时间优先），可抢占，尽早完成耗时短的任务，以取得最小的平均完成时间，是1/2/3中周转时间最佳的调度策略
  - 4）RR（Round Robin，轮转），分为多个时间片，轮流执行所有已到达的任务，是响应时间最佳的调度策略
  - 一种著名的调度方法————MLFQ（Multi-level Feedback Queue，多级反馈队列），有以下几条规则
    - 优先运行高优先级任务
    - 同优先级使用RR调度
    - 任务刚刚进入系统时，放在最高优先级
    - 用完该层时间配额后就降低其优先级
    - 经过一段时间后，就将所有工作重新放入最高优先级队列
# IPC
  https://blog.csdn.net/jojozym/article/details/105638874
  
  - 管道
    - 无名管道，只存在于内存，只可用于父子、兄弟进程之间，单向传输数据，一般适用于信息量不大的场景
    - 有名管道，是FIFO文件，存在于文件系统中，不要求亲缘关系
  - 消息队列
    - 相当于稍微优化的管道，每个进程可以根据消息类型取自己所需的数据而不必FIFO
  - 共享内存
    - 速度最快，适用于信息量大、速度要求快的场景
    - 存在同步问题，通常配合信号量使用
  - 信号
    - 信息量小，通常用于发起简单操作，如CTRL+C
# 僵尸进程、孤儿进程
  - 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
  - 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。
    - 孤儿进程几乎没有危害，僵尸进程则不同，因为如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。
    - 可以通过信号机制解决孤儿进程的危害
