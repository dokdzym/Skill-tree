# 海量数据处理

海量数据处理要解决的有以下几个问题：
- 内存放不下
- 处理速度跟不上数据速度
- 数据在多台机器

通常利用分治思想、Tri树、位图法等。

## TOP N问题 

1. 如何在海量数据中找出重复最多一个。

    - 通过hash映射为小文件

    - 通过hash_map统计各个小文件重复最多的并记录次数

    - 找出重复最多的一个

2. 上亿有重数据，统计最多前N个。

    - 内存存不下

        - 通过hash映射为小文件

        - 通过hash_map统计各个小文件重复最多的并记录次数

        - 对每个小文件重复最多的进行建立大根堆并重复N次取走堆顶并重建堆操作
        
        - 除了建立大根堆，也可以维护一个大小为N的小根堆，遍历到的新值大于小根时替换它并重建。第一种方法耗费空间，第二种方法耗费时间

    - 内存存得下

        - 直接内存通过hash_map统计并建大根堆

        - 重复N次取走堆顶并重建堆操作

3. 海量日志数据，提取出某日访问百度次数最多的那个IP（同1）。

    - 将IP % 1000映射到1000个小文件中
    
        - 相同IP会被映射到同一个文件

        - 不会出现累加和更大情况

    - 分1000次在内存处理小文件，得到频率最大IP（使用map统计）

    - 对这1000个IP建立大根堆

4. 1000w查询串统计最热门10个（同2）。

    - 同上


5. 1G的文件，里面1行1个不超过16字节的词。内存限制1M，返回频数最高前100（同2）。

    - 将单词 % 5000存入5000小文件
    
        - 平均各文件约200K

        - 对超过1M的文件继续分割直到小于200K

    - 使用map统计各个词出现的频率

    - 对5000词使用堆排序或归并排序

## 分布式TOP N问题

6. 分布在100台电脑的海量数据，统计前十。

    - 各数据只出现在一台机器中

        - 先在独立机器得到前十

            - 若可以放入内存直接堆排序

            - 若不可全放入内存：哈希分块 -> map统计 -> 归总堆排

        - 再将100台计算机的TOP10组合起来堆排序

    - 同一元素可同时出现在不同机器中

        - 遍历所有数据，重新hash取模，使同一个元素只出现在单独的一台电脑中，然后采用上面方法先统计每台电脑TOP10再汇总起来

## 快速外排序问题

7. 有10个1G文件，每行都是一个可重复用户query，按query频度排序。

    - 顺序读取十个文件并采取哈希，将query写入10个文件中

    - 通过hash_map(query, count)统计每个query出现次数，至少2G内存

    - 通过得到的hash_map中query和query_count，对query_count排序并将重新输出到文件中，得到已排序好的文件

    - 对十个文件进行归并排序（外排序）

## 公共数据问题

8. A,B两个文件各存放50亿url，每个为64Byte，限制内存4G找出公共url。

    - 对A和B两个大文件，先通过url % 1000将数据映射到1000个文件中，单个文件大小约320M（我们只需要检查对应小文件A1 V B1......，不对应小文件不会有相同url）

    - 通过hash_set统计，把A1的url存储到hash_set中，再遍历对应的B1小文件，检查是否在hash_set中，若存在则写入外存。重复循环处理对应的1000个对。

9. 1000w有重字符串，对字符串去重。

    - 先hash分为多个文件

    - 逐个文件检查并插入set中

    - 多个set取交集

## 内存内TOP N问题

10. 100w个数字找出最大100个。

    - 堆排序法

        - 建大根堆，取走堆顶并重建堆，重复100次

    - 快排法

        - 使用快速排序划分，若某次枢纽元在后10000时（具体情况具体分析），对后10000数据排序后取前100

## 位图法

位图，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。

位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。

假设我们要对 [0,7] 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：

```
0 0 0 0 0 0 0 0
```
然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：
```
0 0 0 0 1 0 1 0
```
依次遍历，结束后，位数组是这样的：
```
0 1 1 0 1 1 1 0
```

每个为 1 的位，它的下标都表示了一个数：
```
for i in range(8):
    if bits[i] == 1:
        print(i)
```

11. 在2.5亿数字中找出不重复的整数。

    - 使用2-Bit位图法，00表示不存在，01表示出现一次，10表示出现多次，11无意义。这样只需要1G内存。

    - 或者hash划分小文件，小文件使用hash_set检查各个元素，得到结果。

12. 如何在40亿数字中快速判断是否有某个数？

    - 位图法标记某个数字是否存在，check标记数组。
    
