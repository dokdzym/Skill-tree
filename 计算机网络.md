# 目录
| Chapter 1 | Chapter 2 | Chapter 3 | Chapter 4|
| :---------: | :---------: | :---------: | :---------: |
| [七层与四层](#七层与四层)|[应用层](#应用层)|[传输层](#传输层)|[网络层](#网络层) |
---

# 内容

## <span id = "七层与四层">七层与四层</span>
### 七层OSI

每一层的协议如下：

- 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS、**TLS**

- 表示层：JPEG、MPEG、ASII、**TLS**

- 会话层：NFS、SQL、NETBIOS、RPC

- 传输层：TCP、UDP、SPX

- 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）

- 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）

- 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）

每一层的作用如下：

- 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）

- 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）

- 会话层：建立、管理和终止会话（会话协议数据单元SPDU）

- 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）

- 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）

- 数据链路层：将比特组装成帧和点到点的传递（帧Frame）

- 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）

### TCP/IP参考模型

共有4层：

- 应用层，例如HTTP、FTP、DNS
（如BGP和RIP这样的路由协议，尽管由于各种各样的原因它们分别运行在TCP和UDP上，仍然可以将它们看作网络层的一部分）

- 传输层，例如TCP、UDP、RTP、SCTP
（如OSPF这样的路由协议，尽管运行在IP上也可以看作是网络层的一部分）

- 网络层，对于TCP/IP来说这是因特网协议（IP）
（如ICMP和IGMP这样的必须协议尽管运行在IP上，也仍然可以看作是网络互连层的一部分；ARP不运行在IP上）

- 网络访问(链接)层，例如以太网、Wi-Fi、MPLS等

PS：

- 上面写着TLS既在应用层又在传输层，但其实没这么简单。传输层安全性协议（英语：Transport Layer Security，缩写：TLS）及其前身安全套接层（英语：Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。

  - OSI模型不适用于SSL，不能100％准确的说在哪个位置。只能表示SSL作用于应用层和传输层之间。如果硬要说在哪个位置，那就是：会话层
  
  - TLS在应用层和传输层之间运行，将应用层数据包装，建立加密会话

- 网络层在七层中的英文是network layer，在四层中的英文是internet layer。网络访问(链接)层的英文是Network Access(link) layer	

## <span id = "应用层">应用层</span>

本节以HTTP为重点，TODO:后面想起来再补充其他协议。

### HTTP

#### HTTP特点

- 端口号80，三次握手即connect，根据ip和端口号发起连接请求

- 浏览器根据HTTP request帮助用户组织好报文头+请求头+信息体（可选）发送给服务器，根据服务器传给浏览器的HTTP response进行网页渲染

- 对于有多个资源的页面，HTTP1.0对每一个文件建立一个TCP连接，传输完数据立马断开，存在效率低下的问题。HTTP1.1保持长连接，传输完毕才断开连接，可能长时间占用服务器资源，导致吞吐率下降。除此之外，还有HTTP0.9和HTTP2.0

#### HTTP1.1与HTTP1.0

在HTTP1.1中，长连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。

HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：

- 缓存处理
- 带宽优化及网络连接的使用
- 错误通知的管理
- 消息在网络中的发送
- 互联网地址的维护
- 安全性及完整性

#### HTTP工作流程

在 **HTTP特点** 中提到了，可以分为以下四个步骤：

- 握手建立连接

- 客户机发送request到服务器（由浏览器代理来组织好request）

- 服务器返回response，并浏览器渲染好响应信息

- 断开连接（HTTP1.0与HTTP1.1不同）


 #### HTTP报文结构
 
 个人主要参考游双的<Linux高性能服务器编程>及Wiki进行这方面的学习。
 由于网上有很多详尽资料，自觉水平有限，难以推陈出新或将冗长的内容进行精确概括，故暂时置空。
 

 
## <span id = "传输层">传输层</span>

可以参考[我的博客](https://blog.csdn.net/jojozym/article/details/106034037?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159341586019724839229962%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=159341586019724839229962&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v4-1-106034037.ecpm_v1_rank_ctr_v4&utm_term=%E8%B0%B7%E6%AD%8CBBR+JOJOZYM)

### TCP

#### TCP拥塞控制算法
- ssthresh:slow start threshold 慢启动阈值，当拥塞窗口cwnd大于该值时，会进入拥塞避免（拥塞控制）阶段。
- Tahoe算法只有快重传而没有快恢复，Reno算法提出了快恢复
- 不同的拥塞控制算法根本差异体现在对报文丢失的处理上
- 关于慢启动
  - 慢启动对于一些短暂的连接性能并不好，一些较旧的网页浏览器会创建大量连续的短暂链接，通过快速开启和关闭链接来请求获得文件，这使得大多数链接处于慢启动模式，导致网页响应时间差。所以现在新的网页浏览器，会通过向特殊的服务器，开启一条链接来请求获得全部的文件，而避免频繁新建大量短暂链接。不过这样对一些非请求网站所提供的服务，例如广告跟踪脚本、社交分享功能脚本、网络分析脚本等，并不适用
##### 快重传是什么
是一种超时重传的改进机制。怎么实现呢？简单地说，当收到对一个报文的三个重复的 ACK 时，认为这个报文的下一个报文丢失了，进入快重传阶段，要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。

比如接收方收到了报文 M1, M2, M4，那么 M4 就称为失序报文。这时会重复发送M2的ACK。

具体可以参考https://blog.csdn.net/wdscq1234/article/details/52476231 谢谢大佬的分享！
##### Reno算法

- 慢启动阶段思路是不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小，在没有出现丢包时每收到一个 ACK 就将拥塞窗口大小加一（单位是 MSS，最大单个报文段长度），每轮次发送窗口增加一倍，呈指数增长，若出现丢包，则将拥塞窗口减半，进入拥塞避免阶段；
- 当窗口达到ssthresh或出现丢包时，进入拥塞避免阶段，窗口每轮次加一，呈线性增长；
- 快重传完成后进入快恢复阶段，将慢启动阈值修改为当前拥塞窗口值的一半，同时拥塞窗口值等于慢启动阈值，然后进入拥塞避免阶段，重复上述过程。
  - 快恢复：一旦出现超时重传，TCP 就会把慢启动门限 ssthresh 的值设置为 cwnd 值的一半（Tahoe算法置为1），同时 cwnd 设置成 1. 但是快恢复算法不这样做。一旦出现超时重传，或者收到第三个重复的 ack 时（快重传），TCP 会把慢启动门限 ssthresh 的值设置为 cwnd 值的一半，同时 cwnd = ssthresh （在有些版本中，会让 cwnd = ssthresh + 3）。
  - 可以参考https://blog.csdn.net/q1007729991/article/details/70185266
- 呈现锯齿状
- 判断拥塞的证据是：ACK超时或者发送方收到对一个报文的三个重复的 ACK（接收方收到乱序包时会发送重复ACK给发送方）
- 和Tahoe算法一样，Reno算法是一种基于丢包的拥塞控制，它跳过了慢启动阶段

##### 谷歌BBR算法

BBR 是谷歌在 2016 年提出的一种新的拥塞控制算法，已经在 Youtube 服务器和谷歌跨数据中心广域网上部署，据 Youtube 官方数据称，部署 BBR 后，在全球范围内访问 Youtube 的延迟降低了 53%，在时延较高的发展中国家，延迟降低了 80%。
- BBR 算法周期性地探测网络的容量，交替测量一段时间内的带宽极大值和时延极小值，将其乘积作为作为拥塞窗口大小，使得拥塞窗口始的值始终与网络的容量保持一致。
- 是一种基于链路容量的拥塞控制


## <span id = "网络层">网络层</span>

可以参考[我的博客](https://blog.csdn.net/jojozym/article/details/106034037?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159341586019724839229962%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=159341586019724839229962&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v4-1-106034037.ecpm_v1_rank_ctr_v4&utm_term=%E8%B0%B7%E6%AD%8CBBR+JOJOZYM)
 
谢谢观看！欢迎勘误
 
