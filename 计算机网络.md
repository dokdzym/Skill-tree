# 目录
| Chapter 1 | Chapter 2 | Chapter 3 | Chapter 4|
| :---------: | :---------: | :---------: | :---------: |
| [七层与四层](#七层与四层)|[应用层](#应用层)|[传输层](#传输层)|[网络层](#网络层) |
---

# 内容

## <span id = "七层与四层">七层与四层</span>
### 七层OSI

每一层的协议如下：

- 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS、**TLS**

- 表示层：JPEG、MPEG、ASII、**TLS**

- 会话层：NFS、SQL、NETBIOS、RPC

- 传输层：TCP、UDP、SPX

- 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）

- 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）

- 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）

每一层的作用如下：

- 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）

- 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）

- 会话层：建立、管理和终止会话（会话协议数据单元SPDU）

- 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）

- 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）

- 数据链路层：将比特组装成帧和点到点的传递（帧Frame）

- 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）

### TCP/IP参考模型

共有4层：

- 应用层，例如HTTP、FTP、DNS
（如BGP和RIP这样的路由协议，尽管由于各种各样的原因它们分别运行在TCP和UDP上，仍然可以将它们看作网络层的一部分）

- 传输层，例如TCP、UDP、RTP、SCTP
（如OSPF这样的路由协议，尽管运行在IP上也可以看作是网络层的一部分）

- 网络层，对于TCP/IP来说这是因特网协议（IP）
（如ICMP和IGMP这样的必须协议尽管运行在IP上，也仍然可以看作是网络互连层的一部分；ARP不运行在IP上）

- 网络访问(链接)层，例如以太网、Wi-Fi、MPLS等

PS：

- 上面写着TLS既在应用层又在传输层，但其实没这么简单。传输层安全性协议（英语：Transport Layer Security，缩写：TLS）及其前身安全套接层（英语：Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。

  - OSI模型不适用于SSL，不能100％准确的说在哪个位置。只能表示SSL作用于应用层和传输层之间。如果硬要说在哪个位置，那就是：会话层
  
  - TLS在应用层和传输层之间运行，将应用层数据包装，建立加密会话

- 网络层在七层中的英文是network layer，在四层中的英文是internet layer。网络访问(链接)层的英文是Network Access(link) layer	

### 粘包问题
  - TCP面向流，UDP面向消息，因此只有TCP存在粘包问题，这不是TCP的设计问题，而是应用层的设计问题，它没有正确理解并处理“流传输”的概念
  - TCP中的粘包问题可以是发送方引起（Nagle算法），也可以是接收方引起（从缓存区取走的速度不够快）
  - 如何解决粘包？
    - 在封装要传输的数据包的时候，采用固定的符号作为结尾符
    - 在数据包中添加长度
    - 短连接（不建议）
    - 环形缓存

## <span id = "应用层">应用层</span>

本节以HTTP为重点，TODO:后面想起来再补充其他协议。

### HTTP

#### HTTP特点

- 端口号80，三次握手即connect，根据ip和端口号发起连接请求

- 浏览器根据HTTP request帮助用户组织好报文头+请求头+信息体（可选）发送给服务器，根据服务器传给浏览器的HTTP response进行网页渲染

- 对于有多个资源的页面，HTTP1.0对每一个文件建立一个TCP连接，传输完数据立马断开，存在效率低下的问题。HTTP1.1保持长连接，传输完毕才断开连接，可能长时间占用服务器资源，导致吞吐率下降。除此之外，还有HTTP0.9和HTTP2.0

#### HTTP1.1与HTTP1.0

在HTTP1.1中，长连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。

HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：

- 缓存处理
- 带宽优化及网络连接的使用
- 错误通知的管理
- 消息在网络中的发送
- 互联网地址的维护
- 安全性及完整性

#### HTTP工作流程

在 **HTTP特点** 中提到了，可以分为以下四个步骤：

- 握手建立连接

- 客户机发送request到服务器（由浏览器代理来组织好request）

- 服务器返回response，并浏览器渲染好响应信息

- 断开连接（HTTP1.0与HTTP1.1不同）

 #### HTTP报文结构
 
 - HTTP请求结构
   - 请求行
     - 请求方法 Space URL Space 协议版本 回车符 换行符
   - 请求头
     - 头部字段:值 回车符 换行符
     - 头部字段:值 回车符 换行符
     - ...
     - 回车符 换行符
   - 请求数据
 - HTTP响应结构
   - 状态行
     - 协议版本 状态码(比如200) 状态信息(比如OK)
   - 消息报头
     - 同样是K:V形式
   - 空行
   - 响应正文
 
 个人主要参考游双的<Linux高性能服务器编程>及Wiki进行这方面的学习。
 由于网上有很多详尽资料，自觉水平有限，难以推陈出新或将冗长的内容进行精确概括，故暂时置空。
 
 #### 响应报文的状态码
 - 100：继续发送请求的剩余部分。
 - 200：成功。
 - 301：内容已经移动。
 - 400：请求不能被服务器理解。
 - 403：无权访问该文件。
 - 404：不能找到请求文件。
 - 500：服务器内部错误。
 - 501：服务器不支持请求的方法。
 - 505：服务器不支持请求的版本。
 
 #### HTTP请求方法
 - GET 请求指定的页面信息，并返回实体主体。
 - HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头
 - POST	向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
 - PUT	从客户端向服务器传送的数据取代指定的文档的内容。
 - DELETE	请求服务器删除指定的页面。
 - CONNECT	HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
 - OPTIONS	允许客户端查看服务器的性能。
 - TRACE	回显服务器收到的请求，主要用于测试或诊断。
 - PATCH	是对 PUT 方法的补充，用来对已知资源进行局部更新。
 
 #### Cookie
  - 形式
    - Cookie是一种key=value形式的字符串，服务器需要记录这个客户端请求的状态，因此在响应头中包一个Set-Cookie字段。响应头如下：

      HTTP/1.0 200 OK

      Set-Cookie:UserID=itbilu; Max-Age=3600; Version=1

      Content-type:text/html
    - 第二次及之后请求头如下：
      GET / HTTP/1.0

      HOST:itbilu.com

      Cookie:UserID=itbilu
  - 类型
    - 分为内存（会话）Cookie和硬盘（持久）Cookie
  - 实现方法：客户端请求服务器后，如果服务器需要记录用户状态，服务器会在响应信息中包含一个Set-Cookie的响应头，客户端会根据这个响应头存储Cookie信息。
  再次请求服务器时，客户端会在请求信息中包含一个Cookie请求头，而服务器会根据这个请求头进行用户身份、状态等较验。


## <span id = "传输层">传输层</span>

可以参考[我的博客](https://blog.csdn.net/jojozym/article/details/106034037?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159341586019724839229962%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=159341586019724839229962&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v4-1-106034037.ecpm_v1_rank_ctr_v4&utm_term=%E8%B0%B7%E6%AD%8CBBR+JOJOZYM)

### TCP

#### TCP头部结构

我习惯从TCP的特点以逻辑树的形式组织记忆其头部结构
- 有连接
  - 16位源端口
  - 16位目的端口
  - 三次握手和四次挥手
    - 6位标志位
      - SYN标志，表示请求建立一个连接。称为同步报文段
      - ACK标志，表示确认号是否有效。称携带ACK标志的TCP报文段为确认报文段
      - FIN标志，表示通知对方本端要关闭连接了。称为结束报文段
      - RST标志，表示要求对方重新建立连接。称携带RST标志的TCP报文段为复位报文段
      - PSH标志，表示接收端应用程序应该立即从TCP接收缓存区读走数据，为后续数据腾出空间（如果不读走，会一直停留在TCP接收缓存区）
      - URG标志， 表示紧急指针是否有效
- 可靠
  - 有序
    - 32位序号
    - 32位确认号
  - 16位校验和，发送端填充，接收端用CRC算法进行检验（不仅检验头部，还检验数据）
- 16位接收窗口大小，用于流量控制
- 16位紧急指针，是一个偏移量，该报文段序号值加上这个偏移量表示一个紧急数据的序号，用于发送端向接收端发送紧急数据
#### TCP拥塞控制算法
- TCP拥塞控制算法的直接作用对象是cwnd
- ssthresh:slow start threshold 慢启动阈值，当拥塞窗口cwnd大于该值时，会进入拥塞避免（拥塞控制）阶段，在该阶段，cwnd随着RTT（round time trip，回路时间）线性增长
- Tahoe算法只有快重传而没有快恢复，Reno算法提出了快恢复
- 不同的拥塞控制算法根本差异体现在对报文丢失的处理上
- 关于慢启动
  - 慢启动对于一些短暂的连接性能并不好，一些较旧的网页浏览器会创建大量连续的短暂链接，通过快速开启和关闭链接来请求获得文件，这使得大多数链接处于慢启动模式，导致网页响应时间差。所以现在新的网页浏览器，会通过向特殊的服务器，开启一条链接来请求获得全部的文件，而避免频繁新建大量短暂链接。不过这样对一些非请求网站所提供的服务，例如广告跟踪脚本、社交分享功能脚本、网络分析脚本等，并不适用
##### 快重传是什么
是一种超时重传的改进机制。怎么实现呢？简单地说，当收到对一个报文的三个重复的 ACK 时，认为这个报文的下一个报文丢失了，进入快重传阶段，要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。

比如接收方收到了报文 M1, M2, M4，那么 M4 就称为失序报文。这时会重复发送M2的ACK。

具体可以参考https://blog.csdn.net/wdscq1234/article/details/52476231 谢谢大佬的分享！
##### Reno算法

- 慢启动阶段思路是不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小，在没有出现丢包时每收到一个 ACK 就将拥塞窗口大小加一（单位是 MSS，最大单个报文段长度），每轮次发送窗口增加一倍，呈指数增长，若出现丢包，则将拥塞窗口减半，进入拥塞避免阶段；
- 当窗口达到ssthresh或出现丢包时，进入拥塞避免阶段，窗口每轮次加一，呈线性增长；
- 快重传完成后进入快恢复阶段，将慢启动阈值修改为当前拥塞窗口值的一半，同时拥塞窗口值等于慢启动阈值，然后进入拥塞避免阶段，重复上述过程。
  - 快恢复：一旦出现超时重传，TCP 就会把慢启动门限 ssthresh 的值设置为 cwnd 值的一半（Tahoe算法置为1），同时 cwnd 设置成 1. 但是快恢复算法不这样做。一旦出现超时重传，或者收到第三个重复的 ack 时（快重传），TCP 会把慢启动门限 ssthresh 的值设置为 cwnd 值的一半，同时 cwnd = ssthresh （在有些版本中，会让 cwnd = ssthresh + 3）。
  - 可以参考https://blog.csdn.net/q1007729991/article/details/70185266
- 呈现锯齿状
- 判断拥塞的证据是：ACK超时或者发送方收到对一个报文的三个重复的 ACK（接收方收到乱序包时会发送重复ACK给发送方）
- 和Tahoe算法一样，Reno算法是一种基于丢包的拥塞控制，它跳过了慢启动阶段

##### 谷歌BBR算法

BBR 是谷歌在 2016 年提出的一种新的拥塞控制算法，已经在 Youtube 服务器和谷歌跨数据中心广域网上部署，据 Youtube 官方数据称，部署 BBR 后，在全球范围内访问 Youtube 的延迟降低了 53%，在时延较高的发展中国家，延迟降低了 80%。
- BBR 算法周期性地探测网络的容量，交替测量一段时间内的带宽极大值和时延极小值，将其乘积作为作为拥塞窗口大小，使得拥塞窗口始的值始终与网络的容量保持一致。
- 是一种基于链路容量的拥塞控制


## <span id = "网络层">网络层</span>

可以参考[我的博客](https://blog.csdn.net/jojozym/article/details/106034037?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159341586019724839229962%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=159341586019724839229962&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v4-1-106034037.ecpm_v1_rank_ctr_v4&utm_term=%E8%B0%B7%E6%AD%8CBBR+JOJOZYM)
 
谢谢观看！欢迎勘误
 
