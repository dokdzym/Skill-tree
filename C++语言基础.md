# 目录
| Chapter 1 | Chapter 2 | Chapter 3| Chapter 4 | 
| :---------: | :---------: | :---------: | :---------: | 
| [编程基础](#base)|[面向对象基础](#oop)|[标准模板库](#stl)|[编译及调试](#other)|
---

# 内容

### <span id = "base">编程基础</span>

**1、零值比较**

如何判断float或者double等于零？分别使用：
- if( abs(f) <= 1e-6)
- if( abs(f) <= 1e-15 )

原因如下：

float是32位，double是64位

float32位中，有1位符号位，8位指数位，23位尾数位

double64位中，有1位符号位，11位指数位，52位尾数位

一般float型只能精确到小数到后六位即1e-6,将float型的数a的绝对值abs（a）与1e-6比较，如果abs（a）比1e-6还要小的话就可以认为a的值为零，因为小数六位以后是不精确的，是没有意义的。比如数0.0000001虽然确实不等于零，但是第七位小数1是没有意义的就可以认为这个数等于0。

float，double分别遵循R32-24,R64-53的标准。

所以float的精度误差在1e-6；double精度误差在1e-15 

所以要判断一个单精度浮点数：则是if( abs(f) <= 1e-6)；要判断一个双精度浮点数：则是if( abs(f) <= 1e-15 )；

**2、结构体内存对齐**

需要注意的有以下几点：

- 结构体内成员按照顺序存储

- 结构体内存大小是最大成员所占内存的整数倍

- 每个成员相对于初始地址（即第一个成员地址）的偏移量是自身所占内存的整数倍

- 为了对齐，可能会加入padding，也就是用于填充的空白内容

**3、C++的内存结构**

C++的内存主要分为内核空间和用户空间。（关于为什么要区分两种空间，可以查看第4点）

对 32 位操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间）为 4G（2的32次方）。也就是说一个进程的最大地址空间为 4G。操作系统的核心是内核(kernel)，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。

为了保证内核的安全，现在的操作系统一般都强制用户进程不能直接操作内核。具体的实现方式基本都是由操作系统将虚拟地址空间划分为两部分，一部分为内核空间，另一部分为用户空间。

针对 Linux 操作系统而言，最高的 1G 字节(从虚拟地址 0xC0000000 到 0xFFFFFFFF)由内核使用，称为内核空间。而较低的 3G 字节(从虚拟地址 0x00000000 到 0xBFFFFFFF)由各个进程使用，称为用户空间。

因此，**每个进程的 4G 地址空间中，最高 1G 都是一样的，即内核空间，被所有进程共享。只有剩余的 3G 才归进程自己使用。**

用户空间又可以分为**堆、栈、数据段、代码段以及自由存储段**

堆：

- 管理方式：依赖于程序员的自觉与能力————malloc/free new/delete 容易引发memory leak。

- 分配过程：操作系统有一个记录空闲内存地址的链表，当使用malloc或者new申请一段内存空间时，寻找首个大于所申请空间的大小的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外，系统会将多余的部分重新放入空闲链表中）。

- 分配效率：由C/C++函数库提供，机制很复杂，因此堆的效率比栈低很多，有碎片。

栈：

- 管理方式：由编译器自动管理。

- 分配过程：只要栈的剩余空间大于所申请空间，系统就会为程序分配内存，否则报异常出现栈空间溢出错误。

- 分配效率：栈是机器系统提供的数据结构，计算机在底层对栈提供支持，分配专门的寄存器存放栈地址，提供栈操作专门的指令，无碎片。

堆向上（高地址）增长而栈向下（低地址）增长。

当一个程序加载到内存中，这块内存就存在两种属性：动态分配内存和静态分配内存。

- 静态分配内存：程序编译和链接时就确定好的内存。
- 动态分配内存：程序加载、调入、执行时分配和回收的内存。


**4、为什么需要区分内核空间和用户空间？内核态和用户态是什么？**

这两个问题可以归为一个，因为————**当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态。**

区分内核空间和用户空间本质上是要提高操作系统的**稳定性及可用性**。

在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清内存、设置时钟等。如果允许所有的程序都可以使用这些指令，那么系统崩溃的概率将大大增加。

所以，CPU 将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。比如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3。

其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别(Windows 系统也是一样的)。当进程运行在 Ring3 级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态。

本篇的主题是C++语言基础，因此这里不再继续展开，也许你可以在**操作系统.md**中阅读相关知识点。

**5、static的用法**

主要分为三种：

- 1、修饰局部变量，此时被static所修饰的变量不会在离开作用域时结束其生命周期，而是在程序结束时才结束。

- 2、修饰全局变量，使该变量对其他源文件(.cpp)隐藏。

- 3、修饰函数，与2、类似，使该函数对其他源文件(.cpp)隐藏。

在1和2中，注意，static变量存储在静态数据区，**其生命周期从程序运行开始，在程序结束时终止**，并且其默认值是0（这里的0可以是整型0，也可以是代表字符串结尾的\0）。

**6、malloc/free与new/delete的区别？**

- 1）malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。

- 2）malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能（delete[]会调用多次析构函数），用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。

- 3）malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。

```
int *a=(int *)malloc(sizeof(int)*len);//len是int数组的长度
```
如上所示，必须进行强制转换`(int *)`。

```
int *a=new int[len];
```
而new后跟着int，已经指定了数据类型，所以不需要强制转换。

- 4）分配内存失败时，new会抛出异常，malloc返回NULL表示开辟内存失败

- 5）释放数组内存时，malloc对应的需要逐一对数组元素free，而new对应的需要用delete[]

- 6)new底层调用了malloc

**7、引用和指针的区别**

- 1）引用不分配额外内存（即它本身无大小，只是一个别名），指针本身占内存

- 2）引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量

- 3）引用不能为空，指针可以为空（nullptr）

关于2）的理解：

```
#include<iostream.h>
void main()
{
       int i = 1, j = 5;
       int& k = i;
       k = j;        //语句1
       cout << " i=" << i << "; j=" << j << "; k=" << k << endl;
}
```
以上代码的运行结果是i=5; j=5; k=5

在语句1中，看起来似乎我们把引用k重新赋值了，但实际上k是i的别名，语句1等价于i = j; 即 语句一完成的是变量赋值而不是引用的重赋值。在已经将k定义为i的引用的前提下，不可能再将k转换为另一个变量的引用。

**7、宏定义(#define)、内联函数(inline)、typedef的用法区别**

可以参考我的博客：https://editor.csdn.net/md/?articleId=104617847

**8、野指针**

野指针有两种来源：

- 1）指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。

- 2）指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。free/delete只是释放了内存空间，但指针值并没有置空，指针变量只有在离开其作用域才会被销毁。
如果把指针比喻为房子（内存空间）的钥匙。只free/delete而不置空，
相当于把房子里的东西清空并退租（内存返回给系统），但房子的钥匙依然在旧租客手上。

用以下伪代码说明野指针在情况2）下的危害：
```
分配内存content，ptr指针指向内存content;
free/delete content;
if(ptr != nullptr){
  std::cout << "content = " << * ptr;//出错
}
```

上述伪代码中展示了一种野指针的危害情况————我们在操作指针指向的内存空间前，为了安全起见，通常先检查指针是否为nullptr。野指针让这种防范措施失效了！
导致我们企图访问一块已经被释放的内存。类比一下大概是这样的情况：**房客退租后（返还给系统）却依然想用旧钥匙（非空指针）打开不属于自己的房子（已释放的内存空间）**

为了避免这样的窘迫境地，程序员应该拥有free/delete后置空（退租前把房子钥匙磨平或者丢到河里）的直觉，否则会被操作系统当头棒喝。

**9、volatile**
- 1）volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。

- 2）C和C++中的volatile并不是用来解决多线程竞争问题的，而是用来修饰一些因为程序不可控因素导致变化的变量，比如访问底层硬件设备的变量，以提醒编译器不要对该变量的访问擅自进行优化。

- 3）对访问共享数据的代码块加锁，已经足够保证数据访问的同步性，再加volatile完全是**多此一举**。
如果光对共享变量使用volatile修饰而在可能存在竞态的场景中不加锁或使用原子操作，那么这对解决多线程竞争没有任何卵用，
因为volatile**并不能保证操作的原子性**，在读取、写入变量的过程中仍然可能被其他线程打断导致意外结果发生。

**10、区别以下指针类型**

```
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```
- int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。

- int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。

- int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。

- int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。

11. 右值引用

- 右值用&&，可以作为重载函数的参数

- 如果临时对象通过一个接受右值的函数传递给另一个函数时，就会变成左值，因为这个临时对象在传递过程中，变成了命名对象。
具体可以参考  https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html  中 **左值和右值的语法符号** //TODO:实现转移构造函数和转移赋值函数

- 标准库函数std::move可以将左值引用转化为右值引用，而右值对应的有一套转移构造函数+转移赋值函数（与拷贝构造函数+赋值函数对应）

12. 单例模式

https://blog.csdn.net/qq_29344757/article/details/75575217 懒汉、饿汉模式实现

13. 为什么静态成员不能在类内初始化？ 

- 静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的

```
class A 
{ 
private: 
static int count ; // 类内声明 
};
 
// 类外定义并初始化，不必再加static关键字
int A::count = 0 ;
```
- static const int可以在类里面初始化

```
//这样不行 
class A { 
private: 
    static int count = 0; // 静态成员不能在类内初始化 
};
 
//这样也不行 
class A { 
private: 
    const int count = 0; // 常量成员也不能在类内初始化 
};
 
//但是这样可以 
class A { 
private: 
    static const int count = 0; // 静态整型常量成员可以在类内初始化，但是 static const float count就不行了 
};
```

14. hash冲突解决方法

- 开放定址法
  - 线性探测法
  - 平方探测法
  - 双散列函数探查法
- 拉链法
- 再哈希法
- 建立公共溢出区
---

### <span id = "oop">面向对象基础</span>

1、空类的大小及内存构成

- 首先，空类大小为1字节。

- 默认函数有：

构造函数

析构函数

拷贝构造函数

赋值运算符

2. 构造函数能否为虚函数，析构函数呢？
   - 析构函数：
      - 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。
      - 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。    
      - 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。
   - 构造函数：
      - 构造函数不能定义为虚函数。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。

3. 构造函数调用顺序，析构函数呢？
   - 调用所有虚基类的构造函数，顺序为从左到右，从最深到最浅

    - 基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。
    
    - 如果该对象需要虚函数指针(vptr)，则该指针会被设置从而指向对应的虚函数表(vtbl)。
    
    - 成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。
    
    - 派生类的构造函数。
    
    - 析构函数与之相反。
    
4、拷贝构造函数和赋值运算符重载的区别？
   - 拷贝构造函数是函数，赋值运算符是运算符重载。
    
   - 拷贝构造函数会生成新的类对象，赋值运算符不能。
   
   - 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。
    
   - 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符，如下：

            Student s;
            Student s1 = s;    // 调用拷贝构造函数
            Student s2;
            s2 = s;    // 赋值运算符操作

   **注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符**
    
5. 虚函数和纯虚函数区别？
   - 虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。
    
   - 纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。

6. 覆盖、重载和隐藏的区别？
   - 覆盖是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。
    
   - 隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。
    
   - 重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。

7、在main执行之前执行的代码可能是什么？

   - 全局对象的构造函数。

8、哪几种情况必须用到初始化成员列表？

   - 初始化一个const成员。
   
   - 初始化一个reference成员。

   - 调用一个基类的构造函数，而该函数有一组参数。

   - 调用一个数据成员对象的构造函数，而该函数有一组参数。

9. 什么是虚指针？

   - 虚指针或虚函数指针是虚函数的实现细节。

   - 虚指针指向虚表结构。

10. 重载和函数模板的区别？

    - 重载需要多个函数，这些函数彼此之间函数名相同，但参数列表中参数数量和类型不同。在区分各个重载函数时我们并不关心函数体。

    - 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表。但只适用于参个数相同而类型不同的函数。

11. this指针是什么？

    - this指针是类的指针，指向对象的首地址。

    - this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。

    - this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。

12. 类模板是什么？

    - 用于解决多个功能相同、数据类型不同的类需要重复定义的问题。

    - 在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。

    - 类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类。

13. 构造函数和析构函数调用时机？

    - 全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。

    - 局部自动对象：建立对象时调用构造函数，离开作用域时调用析构函数。

    - 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。

    - 静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。

---


### <span id = "stl">标准模板库</span>

暂时置空

---

### <span id = "other">编译及调试</span>

**编译**

预处理

- 展开所有的宏定义，完成字符常量替换。

- 处理条件编译语句，通过是否具有某个宏来决定过滤掉哪些代码。

- 处理#include指令，将被包含的文件插入到该指令所在位置。

- 过滤掉所有注释语句。

- 添加行号和文件名标识。

- 保留所有#pragma编译器指令。

编译

- 词法分析。

- 语法分析。

- 语义分析。

- 中间语言生成。

- 目标代码生成与优化。

链接

各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。

- 静态链接

    静态链接最简单的情况就是在编译时和静态库链接在一起成为完整的可执行程序。这里所说的静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib****.a，静态链接所有被用到的目标文件都会复制到最终生成的可执行目标文件中。这种方式的好处是在运行时，可执行目标文件已经完全装载完毕，只要按指令序执行即可，速度比较快，但缺点也有很多，在讲动态链接时会比较一下。

    既然静态链接是对目标文件的打包，这里介绍些打包命令。

        gcc -c test1.c    // 生成test1.o
        gcc -c test2.c    // 生成test2.c
        ar cr libtest.a test1.o test2.o

    首先编译得到test1.o和test2.o两个目标文件，之后通过ar命令将这两个文件打包为.a文件，文件名格式为lib + 静态库名 + .a后缀。在生成可执行文件需要使用到它的时候只需要在编译时加上即可。需要注意的是，使用静态库时加在最后的名字不是libtest.a，而是l + 静态库名。

        gcc -o main main.c -ltest

- 动态链接

    静态链接发生于编译阶段，加载至内存前已经完整，但缺点是如果多个程序都需要使用某个静态库，则该静态库会在每个程序中都拷贝一份，非常浪费内存资源，所以出现了动态链接的方式来解决这个问题。

    动态链接在形式上倒是和静态链接非常相似，首先也是需要打包，打包成动态库，不过文件名格式为lib + 动态库名 + .so后缀。不过动态库的打包不需要使用ar命令，gcc就可以完成，但要注意在编译时要加上-fPIC选项，打包时加上-shared选项。

        gcc -fPIC -c test1.c 
        gcc -fPIC -c test2.c
        gcc -shared test1.o test2.o -o libtest.so

    使用动态链接的用法也和静态链接相同。

        gcc -o main main.c -ltest

如果仅仅像上面的步骤是没有办法正常使用库的，我们可以通过加-Lpath指定搜索库文件的目录（-L.表示当前目录），默认情况下会到环境变量LD_LIBRARY_PATH指定的目录下搜索库文件，默认情况是/usr/lib，我们可以将库文件拷贝到那个目录下再链接。

比较静态库和动态库我们可以得到二者的优缺点。

- 动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。

- 动态库另一个有点就是更新很容易，当库发生变化时，如果接口没变只需要用新的动态库替换掉就可以了。但是如果是静态库的话就需要重新被编译。

- 不过静态库也有优点，主要就是静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会稍微高一些。

makefile编写

对于大的工程通常涉及很多头文件和源文件，编译起来很很麻烦，makefile正是为了自动化编译产生的，makefile像是编译说明书，指示编译的步骤和条件，之后被make命令解释。

- 基本规则

        A:B
        (tab)<command>

    其中A是语句最后生成的文件，B是生成A所依赖的文件，比如生成test.o依赖于test.c和test.h，则写成test.o:test.c test.h。接下来一行的开头必须是tab，再往下就是实际的命令了，比如gcc -c test.c -o test.o。

- 变量

    makefile的书写非常像shell脚本，可以在文件中定义"变量名 = 变量值"的形式，之后需要使用这个变量时只需要写一个$符号加上变量名即可，当然，和shell一样，最好用()包裹起语句来。

**链接**

符号解析

- 可重定位目标文件

    对于独立编译的可重定位目标文件，其ELF文件格式包括ELF头（指定文件大小及字节序）、.text（代码段）、.rodata（只读数据区）、.data（已初始化数据区）、.bss（未初始化全局变量）、.symtab（符号表）等，其中链接时最需要关注的就是符号表。每个可重定位目标文件都有一张符号表，它包含该模块定义和引用的符号的信息，简而言之就是我们在每个模块中定义和引用的全局变量（包括定义在本模块的全局变量、静态全局变量和引用自定义在其他模块的全局变量）需要通过一张表来记录，在链接时通过查表将各个独立的目标文件合并成一个完整的可执行文件。

- 解析符号表

    解析符号引用的目的是将每个引用与可重定位目标文件的符号表中的一个符号定义联系起来。

重定位

- 合并节

    多个可重定位目标文件中相同的节合并成一个完整的聚合节，比如多个目标文件的.data节合并成可执行文件的.data节。链接器将运行时存储地址赋予每个节，完成这步每条指令和全局变量都有运行时地址了。

- 重定位符号引用

    这步修改全部代码节和数据节对每个符号的符号引用，使其指向正确的运行时地址。局部变量可以通过进栈、出栈临时分配，但全局变量（"符号"）的位置则是在各个可重定位目标文件中预留好的。通过上一步合并节操作后，指令中所有涉及符号的引用都会通过一定的寻址方式来定位该符号，比如相对寻址、绝对寻址等。

可执行目标文件

- ELF头部

    描述文件总体格式，并且包括程序的入口点（entry point），也就是程序运行时执行的第一条指令地址。

- 段头部表

    描述了可执行文件数据段、代码段等各段的大小、虚拟地址、段对齐、执行权限等。实际上通过段头部表描绘了虚拟存储器运行时存储映像，比如每个UNIX程序的代码段总是从虚拟地址Ox0804800开始的。

- 其他段

    和可重定位目标文件各段基本相同，但完成了多个节的合并和重定位工作。

加载

- 克隆

    新程序的执行首先需要通过父进程外壳通过fork得到一个子进程，该子进程除了pid等标识和父进程不同外其他基本均与父进程相同。

- 重新映射

    当子进程执行execve系统调用时会先清空子进程现有的虚拟存储器段（简而言之就是不再映射到父进程的各个段），之后重新创建子进程虚拟存储器各段和可执行目标文件各段的映射。这个阶段我们可以理解为对复制来的父进程页表进程重写，映射到外存中可执行文件的各个段。

- 虚页调入

    加载过程并没有实际将磁盘中可执行文件调入内存，所做的工作紧紧是复制父进程页表、清空旧页表、建立新页表映射工作。之后加载器跳转到入口地址_start开始执行程序，接下来的过程需要配合虚拟存储器来完成。CPU获得指令的虚拟地址后，若包含该指令或数据的页尚未调入内存则将其从外存中调入，调入内存后修改页表得到虚拟页号和物理页号的对应关系。之后重新取同一条指令或数据时因该页已经被调入内存，所以通过虚拟地址得到虚拟页号，虚拟页号通过查页表可以得到物理页号，通过物理页号 + 页内偏移得到具体的物理地址，此时可以通过物理地址取得想要的数据。
