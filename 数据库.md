1. ACID
  在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性
  - 原子性（atomicity，或称不可分割性）
    - 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。
    事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
  - 一致性（consistency）
    - 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。
  - 隔离性（isolation，又称独立性）S
    - 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为四个不同级别
  - 持久性（durability）
    - 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

2. 事务隔离级别
  - 未提交读（READ UNCOMMITTED），是最低的隔离级别。允许“脏读”（dirty reads），事务可以看到其他事务“尚未提交”的修改。
  - 提交读（READ COMMITTED），基于锁机制并发控制的DBMS需要对选定对象的写锁一直保持到事务结束，但是读锁在SELECT操作完成后马上释放（因此“不可重复读”现象可能会发生，见下面描述）。和前一种隔离级别一样，也不要求“范围锁”。
  - 可重复读（REPEATABLE READS），是Innodb的默认级别。基于锁机制并发控制的DBMS需要对选定对象的读锁（read locks）和写锁（write locks）一直保持到事务结束，但不要求“范围锁”，因此可能会发生“幻影读”
    - 相对应的不可重复读，即事务A进行两次select操作的中间，其他事务对数据进行update，第一次select操作不可重现，因此叫“不可重复读”。
  - 可串行化，最高的隔离级别，完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞，可以避免幻读。
```
很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。

如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。

所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。

上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。
```

  - 具体可以参考 https://tech.meituan.com/2014/08/20/innodb-lock.html,讲的非常详细
