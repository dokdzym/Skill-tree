# 基于数据库
有以下两种方法
- 基于数据库表
- 基于数据库排它锁
## 基于数据库表
当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。
- 优点
  - 多个分布式请求同时提交到数据库时，数据库来保证只有一个操作会成功
- 缺点
  - 数据库挂掉时，会导致业务不可用
  - 一旦解锁操作失败，其他线程将无法获取到锁
  - 这把锁是非阻塞的，一旦insert失败，就将报错返回，要想获取锁，必须再次请求
  - 不可重入。同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。
- 改进方式
  - 数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。
  - 没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。
  - 非阻塞的？搞一个while循环，直到insert成功再返回成功。
  - 非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。
  
## 基于数据库排它锁
使用Mysql的for update，可以有效的解决上面提到的无法释放锁和阻塞锁的问题。
- 优点
  - 阻塞锁？ for update语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。
  - 锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。
- 缺点
  - for update会一直阻塞，等待 innodb_lock_wait_timeout 的时间（默认是50s），再返回报错，浪费多线程性能
  - 同样依赖于数据库
  - 不可重入
  - 如果一个锁长时间不提交，就会占用数据库连接，可能把数据库连接池撑爆
- 改进
  - 使用Mysql 8.0的新特性for update nowait，无法获取到锁时直接返回错误，不用等待 innodb_lock_wait_timeout 的时间，再返回报错，这样就减少了线程的阻塞时间。

# 基于Redis的Redlock算法
1、客户端获取当前时间，以毫秒为单位。

2、客户端尝试获取 N 个节点的锁，（每个节点获取锁的方式和前面说的缓存锁一样），N 个节点以相同的 key 和 value 获取锁。客户端需要设置接口访问超时，接口超时时间需要远远小于锁超时时间，比如锁自动释放的时间是 10s，那么接口超时大概设置 5-50ms。这样可以在有 redis 节点宕机后，访问该节点时能尽快超时，而减小锁的正常使用。

3、客户端计算在获得锁的时候花费了多少时间，方法是用当前时间减去在步骤一获取的时间，只有客户端获得了超过 3 个节点的锁，而且获取锁的时间小于锁的超时时间，客户端才获得了分布式锁。

4、客户端获取的锁的时间为设置的锁超时时间减去步骤三计算出的获取锁花费时间。

5、如果客户端获取锁失败了，客户端会依次删除所有的锁。

- 优点
  - 只要还存在一个节点，分布式锁服务就能工作，这相比之前的数据库锁和缓存锁大大提高了可用性，由于 redis 的高效性能，分布式缓存锁性能并不比数据库锁差。
- 缺点
  - 锁的失效时间可以设置为5`50s，如果太短则任务没结束，锁就自动释放了。太长则浪费其他线程的等待时间。
  
